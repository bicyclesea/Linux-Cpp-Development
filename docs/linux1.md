# Linux系统编程（1）

# Linux系统编程之基础篇01

## 1. (1) 整理ls -l各列的含义 (3) 目录文件的内容是一个什么结构，存储了哪些信息？(2) 什么是硬链接？目录和硬链接存在什么关系？

【答】

（1）**ls -l各列的含义**



（2）**硬链接**



**关系**



（3）**结构**



**信息**



## 2. (1) 检查一下自己的内核版本，在互联网上查询当前最新的内核版本。(2) Linux的系统可以分成哪几层结构，分别有什么功能？

【答】

（1）**自己的内核版本**



**当前最新的内核版本**



（2）**结构**



**功能**



## 3. 以表格的形式整理用户（查询、切换、配置密码、增加和删除）相关命令。

【答】**用户相关命令**



## 4. (1) Linux的虚拟文件系统采用什么类型的数据结构组织的？目录文件和普通文件在数据结构中扮演着怎么样不同的角色？(2) 什么是路径、相对路径和绝对路径？(3) 普通用户家目录在何方？如何快速将当前工作目录切换到家目录。(4) 整理cd命令的几种用法。

【答】

（1）**类型**



**目录文件**



**普通文件**

（2）**路径**

**相对路径**

**绝对路径**



（3）**普通用户家目录**

**方法**

（4）**用法**



## 总结





# Linux系统编程之基础篇02

## 1. 在/usr/share/doc找到所有以html结尾且大小大于100个block的文件，并且使用ls -l展示其详细信息。

【答】

**文件**



**详细信息**



## 2. 整理学习过的正则表达式规则。

【答】



## 3. 尝试一下vimtutor命令，按照要求练习一下，记录使用到的快捷键。

【答】



## 总结





# Linux系统编程之基础篇03

## 1. 使用gdb调试程序，整理调试所用到的所有快捷键。使用gdb调试core文件，并检查出错时的堆栈信息。可以使用以下代码进行调试。

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
int value;
struct Node *next;
} Node;

// 尾插法插入结点
void add_before_tail(Node **head, int value) {
Node *new_node = (Node *)malloc(sizeof(Node));
new_node->value = value;
new_node->next = NULL;
if (*head == NULL) {
  head = new_node;
} else {
  Node *temp = *head;
  while (temp != NULL) {
      temp = temp->next;
  }
  temp->next = new_node;
}
}

// 打印链表中的所有值
void print_list(Node *head) {
Node *current = head;
while (current != NULL) {
	 current = current->next;
  printf("%d -> ", current->value);
}
printf("NULL\n");
}

int main() {
Node *head = NULL;
add_before_tail(&head, 1);
add_before_tail(&head, 2);
add_before_tail(&head, 3);

print_list(head);
return 0;
}
```

答：



## 2. 说明一下使用动态库和静态库的区别，然后分别生成动态库和静态库。可以直接参考文档笔记中的实现。主要是自己练习一下生成库文件的指令。

答：



## 3. 一个目录中有三个.c文件：main.c add.c subtract.c(内容无所谓)，最终将它们生成一个可执行程序main。请编写这个Makefile文件。一个目录中有三个.c文件：test.c test2.c test3.c(内容无所谓)，它们都有自己的main函数，都要最终生成独立的可执行程序：test、test2、test3。请编写这个Makefile文件。注意：要求实现clean清理和rebuild重建功能。注：可以考虑将你写的Makefile尽量提高通用性。

答：



## 总结





# Linux系统编程之基础篇04

## 1. 请按照章节《HelloWorld》配置Linux开发环境。配置好公共头文件、Makefile以及.c文件模板。最后实现一个标准C语言的文件流文件复制，将代码提交上来。



## 2. 以下小题目，请利用学过的目录相关操作函数实现：（1）打印列出目录中的所有文件和子目录，要求列出dirent结构体的所有信息（不用递归，只看一级目录）。（2）自己生成一个目录，感受一下telldir和seekdir的使用。（3）往后预习，尝试自己写一下ls -al的实现。



## 总结





# Linux系统编程之基础篇05

## 1. 实现：（1）无排序功能的ls -al指令（2）实现简化版tree指令


## 总结



# Linux系统编程之基础篇06

## 1. 请实现fopen/open/mmap三种形式的文件复制。然后自己测试比较一下它们的性能。



## 2. 定义一个学生结构体类型struct student，里边含有学号(int)，姓名，分数(float)。定义结构体数组struct student s[3],给数组赋初值后，写入文件，然后通过lseek偏移到开头，然后再读取并使用printf输出。





## 3. 利用dup实现重定向功能：（1）重定向标准输出到文件（2）标准输入重定向到文件, 从文件读数据（3）实现在标准输出重定向到文件, 复原,再重定向到文件的反复横跳（4）重定向标准错误到文件server.log中, 实现类似打印日志的功能。





## 总结



# 1007 Linux系统编程之文件系统01

## 1. 编写程序A和B。A负责将文件的名字、长度和内容通过管道发送B，B需要新建一个目录，并将该文件存储起来。





## 2. 实现即时聊天，如果对方连续10s没有发送任何消息则断开连接。（注意，即使本方在10s内从标准输入当中输入数据也不行）。



## 总结



# 1008 Linux系统编程之进程管理01

## 1. 说明一下什么是进程，什么是虚拟内存，什么是虚拟CPU？

答：



## 2. 编写C程序验证ps命令显示的是有效用户ID，还是真实用户ID。作业中应该包括代码、操作每个步骤和命令以及最终结果的截图。

答：



## 3. 使用思维导图整理所学过的所有进程相关的命令。

答：



## 4. (1). 请问下面的程序一共输出多少个“-”。(2). 上题中的printf("-")换成printf("-\n")；程序会输出多少个“-”?思考一下为什么？把进程地址空间的图画出来。

```c
int main()
{
  printf("-");
  fork();
  printf("-");
  fork();
  return 0;
}
```

答：



## 总结



# 1009 Linux系统编程之进程管理02

## 1. 说明什么是孤儿进程，什么是僵尸进程，他们对操作系统有什么影响？书写代码创建孤儿进程和僵尸进程。



## 2. 进程的结束方式有哪些？return、_exit和exit有什么区别？



## 3. 实现一个守护进程。



## 4. 书写两个可执行程序：

可执行程序一：

  父进程负责创建子进程并且最后回收其资源；

  子进程加载可执行程序二。

可执行程序二：

  列出当前目录所有文件的文件名。

---

答：



## 5. 验证匿名管道的性质：

1、是否发生读阻塞？

2、是否发生写阻塞？

3、读端先关闭，写端继续写会怎么样？

4、写端先关闭，读端继续读会怎么样？

---

答：



## 总结

- 



# 1010 Linux系统编程之进程管理03

## 1. 新建共享内存，连接，然后往共享内存写入How are you,然后另外一个进程连接共享内存，读取数据并打印显示,最后删除共享内存。 提交操作记录和相关代码。

答：



## 2. fork创建一个子进程，两个进程访问同一段共享内存，共享内存里保存一个整形数，父子进程用for循环的方式。每次对这个整形数字加1，父子进程各循环1000万次。加完后打印一下共享内存里的数字，看看是多少？

答：





## 总结

- 



# 1011 Linux系统编程之进程管理04

## 1. signal的作用是什么？会不会导致阻塞？handler函数会在什么情况下调用？使用同一个handler去注册不同的信号，效果怎么样？

答：



## 2. 信号递送过程中，产生了另一个同类信号会怎么样？产生了另两个、三个、多个同类信号会怎么样？写代码验证一下你的想法。说明mask和pending如何变化。

答：



## 3. 使用sigaction注册2号信号的处理函数。1） 允许自动重启低速系统调用；2）在处理2号信号时阻塞3号信号，不会被3号信号打断；3）在2号信号的信号处理函数中，使用sigpending函数判断一下有没有3号信号处于未决状态。

答：



## 4. 通过sigprocmask阻塞2号信号，睡眠5秒后，解除阻塞，2号信号得到执行；在睡眠后，解除阻塞之前，通过sigpending检测是否有信号挂起。

答：



## 5. 完成窗口聊天：

## （1）通信方式：

\- A进程和B进程负责通信，从标准输入读到的字符串通过管道发给对方
\- A进程从标准输入读到的字符串发给B进程后，B打印到屏幕上。
\- B进程从标准输入读到的字符串发给A进程，A打印到屏幕上。
（2）退出方式：
任意一个进程在标准输入收到输入1，给所有进程（通信双方）发送10号信号，每个进程收到10号信号后，开始执行有序退出。

答：





## 总结

- 



# 1012 Linux系统编程之多线程01

## 1. 什么是线程？线程和进程有哪些区别？

答：



## 2. `pthread_join`为什么需要一个`void **`参数？书写程序，创建3个子线程，然后等待所有的子线程终止，最后获取其退出状态。

答：



## 总结



# 1013 Linux系统编程之多线程02

## 1. 线程的清理函数什么时候会执行？什么情况下线程退出的时候不会执行清理函数？



## 2. 从源码角度说明为什么`pthread_cleanup_push`和`pthread_cleanup_pop`必须成对出现？



## 3. 尝试使用2个线程对同一个全局变量各加2000万(或者更多次)，统计加锁解锁的消耗。使用gettimeofday可以获取高精度当前时间(参考预习文档上对gettimeofday使用说明)。



## 总结



# 1014 Linux系统编程之多线程03

## 1. 现在有两个线程t1和t2，t1 打印 A 和 C，t2 打印 B。书写代码，使用条件变量每次的显示顺序都是A->B->C。代码书写完成后，回答问题：条件变量中加锁的目的是什么？

答：



## 2. 主线程执行事件A，子线程执行事件B，在AB事件之外不使用sleep，使用循环机制配合互斥锁，确保B一定在A完成之后运行。

```c++
A:
  printf("Before A!\n");
  sleep(3)
  printf("After A\n");
B:
  printf("Before B!\n");
  sleep(3)
  printf("After B\n");
```

答：



## 3. 文档上给的生产者消费者代码示例，有时间可以写写练练优化优化。

答：





## 总结

- 





















